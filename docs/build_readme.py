"""Build README.md from readme.ipynb with GitHub URLs for images."""

import glob
import os
import re
import shutil
import subprocess

# Paths
DOCS_DIR = "docs"
NOTEBOOK_PATH = os.path.join(DOCS_DIR, "readme.ipynb")
README_PATH = "README.md"
IMAGES_DIR = os.path.join(DOCS_DIR, "images")
TEMP_FILES_DIR = "README_files"


def get_github_repo_info():
    """Extract GitHub repository information from git remote."""
    try:
        # Get remote URL
        result = subprocess.run(
            ["git", "config", "--get", "remote.origin.url"],
            capture_output=True,
            text=True,
            check=True,
        )
        remote_url = result.stdout.strip()

        # Parse GitHub URL (supports both HTTPS and SSH)
        # HTTPS: https://github.com/user/repo.git
        # SSH: git@github.com:user/repo.git
        pattern = r"github\.com[:/](.+)/(.+?)(?:\.git)?$"
        match = re.search(pattern, remote_url)

        if not match:
            raise ValueError(f"Could not parse GitHub URL: {remote_url}")

        user = match.group(1)
        repo = match.group(2)

        # Get current branch
        result = subprocess.run(
            ["git", "branch", "--show-current"],
            capture_output=True,
            text=True,
            check=True,
        )
        branch = result.stdout.strip()

        return user, repo, branch

    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Failed to get git info: {e}")


def get_github_raw_url():
    """Get the GitHub raw content URL for the current repository."""
    user, repo, branch = get_github_repo_info()
    return f"https://raw.githubusercontent.com/{user}/{repo}/{branch}"


def clean_existing_images():
    """Remove existing generated images, keeping only the logo."""
    if not os.path.exists(IMAGES_DIR):
        return
    
    print("Cleaning old images...")
    for image_file in glob.glob(os.path.join(IMAGES_DIR, "*.svg")):
        os.remove(image_file)
        print(f"  Removed {os.path.basename(image_file)}")


def convert_notebook_to_markdown():
    """Convert notebook to markdown with execution and use GitHub URLs."""
    print("Converting notebook to markdown...")

    # Clean old images first
    clean_existing_images()

    # Run jupyter nbconvert with execution
    result = subprocess.run(
        [
            "uv",
            "run",
            "jupyter",
            "nbconvert",
            "--to",
            "markdown",
            "--output",
            "README",
            "--output-dir",
            ".",
            "--execute",
            NOTEBOOK_PATH,
            '--ExtractOutputPreprocessor.extract_output_types={"image/svg+xml"}',
        ],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Error: {result.stderr}")
        return False
    print("Notebook executed and converted to markdown")

    # Move images and update URLs
    move_images_and_update_urls()

    return True


def move_images_and_update_urls():
    """Move images from temp directory to docs/images and update URLs."""

    if not os.path.exists(TEMP_FILES_DIR):
        print("No images to move")
        return

    # Find all SVG files generated by nbconvert
    svg_files = glob.glob(os.path.join(TEMP_FILES_DIR, "*.svg"))

    if not svg_files:
        shutil.rmtree(TEMP_FILES_DIR)
        print("No SVG files found")
        return

    print(f"Moving {len(svg_files)} images...")

    # Read README content
    with open(README_PATH) as f:
        readme_content = f.read()

    # Create images directory
    os.makedirs(IMAGES_DIR, exist_ok=True)

    # Get GitHub URL
    github_raw_url = get_github_raw_url()

    # Move each image and update its URL in the README
    for svg_file in svg_files:
        filename = os.path.basename(svg_file)
        destination = os.path.join(IMAGES_DIR, filename)

        # Move file
        shutil.move(svg_file, destination)

        # Update markdown reference from local path to GitHub URL
        local_path = f"{TEMP_FILES_DIR}/{filename}"
        github_url = f"{github_raw_url}/docs/images/{filename}"
        readme_content = readme_content.replace(local_path, github_url)

        print(f"  - {filename}")

    # Write updated README
    with open(README_PATH, "w") as f:
        f.write(readme_content)

    # Remove temp directory
    shutil.rmtree(TEMP_FILES_DIR)
    print("Images moved and URLs updated")


def verify_images():
    """Verify that all image URLs in README point to existing files."""
    with open(README_PATH) as f:
        readme_content = f.read()

    # Get GitHub URL
    github_raw_url = get_github_raw_url()

    # Find all GitHub image URLs in README
    url_pattern = re.escape(github_raw_url) + r"/docs/images/([\w_]+\.svg)"
    image_filenames = re.findall(url_pattern, readme_content)

    if not image_filenames:
        print("Warning: No image URLs found in README")
        return False

    print(f"Found {len(image_filenames)} image URLs")

    # Check that all referenced files exist
    missing = []
    for filename in image_filenames:
        file_path = os.path.join(IMAGES_DIR, filename)
        if not os.path.exists(file_path):
            missing.append(filename)

    if missing:
        print(f"Error: Missing images: {', '.join(missing)}")
        return False

    print(f"All image files exist")
    return True


def main():
    """Build README.md from notebook."""

    # Verify we're in the repository root
    if not os.path.exists(DOCS_DIR):
        print(f"Error: {DOCS_DIR}/ not found. Run from repository root.")
        return 1

    # Convert notebook and process images
    if not convert_notebook_to_markdown():
        print("\nBuild failed")
        return 1

    # Verify images are correctly referenced
    verify_images()

    print("README.md built successfully")
    return 0


if __name__ == "__main__":
    exit(main())
